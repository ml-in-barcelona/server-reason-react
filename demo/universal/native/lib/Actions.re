// Reasonml don't accept to spread args so we pass all the args as a list
// But react-server-dom-webpack on encodeReply get the args also as a list
// having a nested list, where the hd of this list is the args
// That's why I created this function to decode the body
[@platform native]
let getArgs = body => {
  Yojson.Basic.from_string(body)
  |> Yojson.Basic.Util.to_list
  |> List.hd
  |> Yojson.Basic.Util.to_list;
};

module Notes = {
  [@platform native]
  let createNoteResponse = note => {
    React.Json(
      Note.(
        `Assoc([
          ("id", `Int(note.id)),
          ("title", `String(note.title)),
          ("content", `String(note.content)),
          ("updated_at", `Float(note.updated_at)),
        ])
      ),
    );
  };

  // Lets say this is the server action declared by the user
  [@platform native]
  let createHandler = (~title, ~content) => {
    let note = DB.addNote(~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(createNoteResponse(note))
      | Error(e) => Lwt.return(React.Json(`String(e)))
      };
    Lwt.return(response);
  };
  [@platform native]
  let createRouteHandler = body => {
    // Parse the body to get the args
    // This will be generated by some ppx
    let (title, content) =
      switch (getArgs(body)) {
      | [title, content] => (
          // It would be handle by a title_of_json/content_of_json in the future
          title |> Yojson.Basic.Util.to_string,
          content |> Yojson.Basic.Util.to_string,
        )
      | _ => failwith(Printf.sprintf("Invalid arguments %s", body))
      };

    createHandler(~title, ~content);
  };

  // This is the action generated to be used under the hood for the server and client
  let create =
    switch%platform () {
    | Server => (Router.demoActionCreateNote, "null")
    | Client => (
        (~title, ~content) => {
          // Register the action for the client
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionCreateNote,
              Some("create"),
            );

          action((title, content));
        }
      )
    };

  // Lets say this is the server action declared by the end-user
  [@platform native]
  let editHandler = (~id, ~title, ~content) => {
    let note = DB.editNote(~id, ~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(createNoteResponse(note))
      | Error(e) => Lwt.return(React.Json(`String(e)))
      };

    Lwt.return(response);
  };
  [@platform native]
  let editRouteHandler = body => {
    // Parse the body to get the args
    // This will be generated by some ppx
    let (id, title, content) =
      switch (getArgs(body)) {
      | [id, title, content] => (
          // It would be handle by a id_of_json/title_of_json/content_of_json in the future
          id |> Yojson.Basic.Util.to_int,
          title |> Yojson.Basic.Util.to_string,
          content |> Yojson.Basic.Util.to_string,
        )
      | _ => failwith(Printf.sprintf("Invalid arguments %s", body))
      };

    editHandler(~id, ~title, ~content);
  };

  // This is the action generated to be used under the hood for the server and client
  let edit =
    switch%platform () {
    | Server => (Router.demoActionEditNote, "null")
    | Client => (
        (~id, ~title, ~content) => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionEditNote,
              Some("edit"),
            );
          // With multiple arguments, we can pass them directly as a tuple
          action((id, title, content));
        }
      )
    };

  // Lets say this is the server action declared by the end-user
  [@platform native]
  let deleteHandler = (~id) => {
    let _ = DB.deleteNote(id);
    let response = React.Json(`String("Note deleted"));
    Lwt.return(response);
  };
  [@platform native]
  let deleteRouteHandler = body => {
    // Parse the body to get the args
    // This will be generated by some ppx
    let id =
      switch (getArgs(body)) {
      | [id] => id |> Yojson.Basic.Util.to_int
      | _ => failwith(Printf.sprintf("Invalid arguments %s", body))
      };

    deleteHandler(~id);
  };

  // This is the action generated to be used under the hood for the server and client
  let delete =
    switch%platform () {
    | Server => (Router.demoActionDeleteNote, "null")
    | Client => (
        id => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionDeleteNote,
              Some("delete"),
            );
          // With a single argument, we need to pass an array
          action([|id|]);
        }
      )
    };
};

module Samples = {
  [@platform native]
  let formDataHandler = formData => {
    let (_, name) = Hashtbl.find(formData, "name") |> List.hd;
    let (_, lastName) = Hashtbl.find(formData, "lastName") |> List.hd;
    let (_, age) = Hashtbl.find(formData, "age") |> List.hd;

    Dream.log("Hello %s %s, you are %s years old", name, lastName, age);

    Lwt.return(
      React.Json(`String("Hello from server with form data action")),
    );
  };
  [@platform native]
  let formDataRouteHandler = formData => formDataHandler(formData);

  let formData =
    switch%platform () {
    | Server => (Router.demoActionFormDataSample, "null")
    | Client => (
        formData => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionFormDataSample,
              Some("formData"),
            );
          action(formData);
        }
      )
    };

  [@platform native]
  let formDataServerOnlyHandler = formData => {
    let (_, name) = Hashtbl.find(formData, "name") |> List.hd;
    let (_, lastName) = Hashtbl.find(formData, "lastName") |> List.hd;
    let (_, age) = Hashtbl.find(formData, "age") |> List.hd;

    Dream.log("Hello %s %s, you are %s years old", name, lastName, age);

    Lwt.return(
      React.Json(`String("Hello from server with form data action")),
    );
  };
  [@platform native]
  let formDataServerOnlyRouteHandler = formData =>
    formDataServerOnlyHandler(formData);

  // This server only action is not registered for the client
  let formDataServerOnly = (Router.demoActionFormDataServerOnly, "null");

  [@platform native]
  let simpleResponseHandler = () => {
    Lwt.return(
      React.Json(`String("Hello from server with simple response action")),
    );
  };
  [@platform native]
  let simpleResponseRouteHandler = _ => simpleResponseHandler();

  let simpleResponse =
    switch%platform () {
    | Server => (Router.demoActionSimpleResponse, "null")
    | Client => (
        _ => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionSimpleResponse,
              Some("simpleResponse"),
            );
          action();
        }
      )
    };
};
