// Reasonml don't accept to spread args so we pass all the args as a list
// But react-server-dom-webpack on encodeReply get the args also as a list
// having a nested list, where the hd of this list is the args
// That's why I created this function to decode the body
[@platform native]
let getArgs = body => {
  Yojson.Basic.from_string(body)
  |> Yojson.Basic.Util.to_list
  |> List.hd
  |> Yojson.Basic.Util.to_list;
};

module Notes = {
  [@platform native]
  let createNoteResponse = note => {
    React.Json(
      Note.(
        `Assoc([
          ("id", `Int(note.id)),
          ("title", `String(note.title)),
          ("content", `String(note.content)),
          ("updated_at", `Float(note.updated_at)),
        ])
      ),
    );
  };

  // Lets say this is the server action declared by the user
  [@platform native]
  let createHandler = (~title, ~content) => {
    let note = DB.addNote(~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(createNoteResponse(note))
      | Error(e) => Lwt.return(React.Json(`String(e)))
      };
    Lwt.return(response);
  };

  // This is the action generated to be used under the hood for the server and client
  let create =
    switch%platform () {
    | Server => (
        body => {
          // Parse the body to get the args
          // This will be generated by some ppx
          let (title, content) =
            switch (getArgs(body)) {
            | [title, content] => (
                // It would be handle by a title_of_json/content_of_json in the future
                title |> Yojson.Basic.Util.to_string,
                content |> Yojson.Basic.Util.to_string,
              )
            | _ => failwith(Printf.sprintf("Invalid arguments %s", body))
            };

          createHandler(~title, ~content);
        }
      )
    | Client => (
        (~title, ~content) => {
          // Register the action for the client
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionCreateNote,
              Some("actionCreateNote"),
            );

          action((title, content));
        }
      )
    };

  // Lets say this is the server action declared by the end-user
  [@platform native]
  let editHandler = (~id, ~title, ~content) => {
    let note = DB.editNote(~id, ~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(createNoteResponse(note))
      | Error(e) => Lwt.return(React.Json(`String(e)))
      };

    Lwt.return(response);
  };

  // This is the action generated to be used under the hood for the server and client
  let edit =
    switch%platform () {
    | Server => (
        body => {
          // Parse the body to get the args
          // This will be generated by some ppx
          let (id, title, content) =
            switch (getArgs(body)) {
            | [id, title, content] =>
              Dream.log(
                "Edit note: %s %s %s",
                Yojson.Basic.show(id),
                Yojson.Basic.show(title),
                Yojson.Basic.show(content),
              );
              (
                // It would be handle by a id_of_json/title_of_json/content_of_json in the future
                id |> Yojson.Basic.Util.to_int,
                title |> Yojson.Basic.Util.to_string,
                content |> Yojson.Basic.Util.to_string,
              );
            | _ => failwith(Printf.sprintf("Invalid arguments %s", body))
            };

          let note = DB.editNote(~id, ~title, ~content);
          let%lwt response =
            switch%lwt (note) {
            | Ok(note) => Lwt.return(createNoteResponse(note))
            | Error(e) => Lwt.return(React.Json(`String(e)))
            };

          Lwt.return(response);
        }
      )
    | Client => (
        (~id, ~title, ~content) => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionEditNote,
              Some("actionEditNote"),
            );
          // With multiple arguments, we can pass them directly as a tuple
          action((id, title, content));
        }
      )
    };

  // Lets say this is the server action declared by the end-user
  [@platform native]
  let deleteHandler = (~id) => {
    let _ = DB.deleteNote(id);
    let response = React.Json(`String("Note deleted"));
    Lwt.return(response);
  };

  // This is the action generated to be used under the hood for the server and client
  let delete =
    switch%platform () {
    | Server => (
        body => {
          // Parse the body to get the args
          // This will be generated by some ppx
          let id =
            switch (getArgs(body)) {
            | [id] => id |> Yojson.Basic.Util.to_int
            | _ => failwith(Printf.sprintf("Invalid arguments %s", body))
            };
          deleteHandler(~id);
        }
      )
    | Client => (
        id => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionDeleteNote,
              Some("actionDeleteNote"),
            );
          // With a single argument, we need to pass an array
          action([|id|]);
        }
      )
    };
};

module Samples = {
  let formData =
    switch%platform () {
    | Server => (
        formData => {
          let (_, name) = Hashtbl.find(formData, "name") |> List.hd;
          let (_, lastName) = Hashtbl.find(formData, "lastName") |> List.hd;
          let (_, age) = Hashtbl.find(formData, "age") |> List.hd;

          Dream.log("Hello %s %s, you are %s years old", name, lastName, age);

          Lwt.return(
            React.Json(`String("Hello from server with form data action")),
          );
        }
      )
    | Client => (
        formData => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionFormDataSample,
              Some("actionFormDataSample"),
            );
          action(formData);
        }
      )
    };

  let simpleResponse =
    switch%platform () {
    | Server => (
        _ => {
          Lwt.return(
            React.Json(
              `String("Hello from server with simple response action"),
            ),
          );
        }
      )
    | Client => (
        _ => {
          let action =
            ReactServerDOMWebpack.createServerReference(
              Router.demoActionSimpleResponse,
              Some("actionSimpleResponse"),
            );
          action();
        }
      )
    };
};
