module Notes = {
  [@platform native]
  let createNoteResponse = note => {
    Note.(
      `Assoc([
        ("id", `Int(note.id)),
        ("title", `String(note.title)),
        ("content", `String(note.content)),
        ("updated_at", `Float(note.updated_at)),
      ])
    );
  };

  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let createHandler = (~title, ~content) => {
      let note = DB.addNote(~title, ~content);
      let%lwt response =
        switch%lwt (note) {
        | Ok(note) => Lwt.return(createNoteResponse(note))
        | Error(e) => failwith(e)
        };
      Lwt.return(response);
    };
   */
  // It's going to be on top to this that we are going to generate the codes bellow
  let createId = "id/notes/create";

  [@platform native]
  let createHandler = (~title, ~content) => {
    let note = DB.addNote(~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(createNoteResponse(note))
      | Error(e) => failwith(e)
      };
    Lwt.return(response);
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let createRouteHandler = args => {
    // Parse the body to get the args
    let (title, content) =
      switch (args) {
      | [title, content] => (
          // It would be handle by a title_of_json/content_of_json in the future provided by the end-user and the ppx
          title |> Yojson.Basic.Util.to_string,
          content |> Yojson.Basic.Util.to_string,
        )
      | _ =>
        failwith(
          Printf.sprintf(
            "Invalid arguments %s",
            args
            |> List.map(Yojson.Basic.Util.to_string)
            |> String.concat(","),
          ),
        )
      };

    createHandler(~title, ~content)
    |> Lwt.map(response => React.Json(response));
  };

  // This is the action generated to be used under the hood for the server and client
  let create =
    switch%platform () {
    | Server =>
      failwith("We don't support Server Functions on server side yet")
    | Client => (
        (~title, ~content) => {
          // Register the action for the client
          let action = ReactServerDOMEsbuild.createServerReference(createId);
          action(. title, content);
        }
      )
    };

  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let editHandler = (~id, ~title, ~content) => {
      let note = DB.editNote(~id, ~title, ~content);
      let%lwt response =
        switch%lwt (note) {
        | Ok(note) => Lwt.return(createNoteResponse(note))
        | Error(e) => failwith(e)
        };
      Lwt.return(response);
    };
  */
  // It's going to be on top to this that we are going to generate the codes bellow
  let editId = "id/notes/edit";

  [@platform native]
  let editHandler = (~id, ~title, ~content) => {
    let note = DB.editNote(~id, ~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(createNoteResponse(note))
      | Error(e) => failwith(e)
      };

    Lwt.return(response);
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let editRouteHandler = args => {
    // Parse the body to get the args
    // This will be generated by some ppx
    let (id, title, content) =
      switch (args) {
      | [id, title, content] => (
          // It would be handle by a id_of_json/title_of_json/content_of_json in the future provided by the end-user and the ppx
          id |> Yojson.Basic.Util.to_int,
          title |> Yojson.Basic.Util.to_string,
          content |> Yojson.Basic.Util.to_string,
        )
      | _ =>
        failwith(
          Printf.sprintf(
            "Invalid arguments %s",
            args
            |> List.map(Yojson.Basic.Util.to_string)
            |> String.concat(","),
          ),
        )
      };

    editHandler(~id, ~title, ~content)
    |> Lwt.map(response => React.Json(response));
  };

  // This is the action generated to be used under the hood for the server and client
  let edit =
    switch%platform () {
    | Server => failwith("We don't support Server Functions on server ")
    | Client => (
        (~id, ~title, ~content) => {
          let action = ReactServerDOMEsbuild.createServerReference(editId);

          action(. id, title, content);
        }
      )
    };

  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let deleteHandler = (~id) => {
      let _ = DB.deleteNote(id);
      let response = `String("Note deleted");
      Lwt.return(response);
    };
  */
  // It's going to be on top to this that we are going to generate the codes bellow
  let deleteId = "id/notes/delete";

  [@platform native]
  let deleteHandler = (~id) => {
    let _ = DB.deleteNote(id);
    let response = `String("Note deleted");
    Lwt.return(response);
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let deleteRouteHandler = args => {
    // Parse the body to get the args
    // This will be generated by some ppx
    let id =
      // It would be handle by a id_of_json in the future provided by the end-user and the ppx
      switch (args) {
      | [id] => id |> Yojson.Basic.Util.to_int
      | _ =>
        failwith(
          Printf.sprintf(
            "Invalid arguments %s",
            args
            |> List.map(Yojson.Basic.Util.to_string)
            |> String.concat(","),
          ),
        )
      };

    deleteHandler(~id) |> Lwt.map(response => React.Json(response));
  };

  // This is the action generated to be used under the hood for the server and client
  let delete =
    switch%platform () {
    | Server => failwith("We don't support Server Functions on server ")
    | Client => (
        (~id) => {
          let action = ReactServerDOMEsbuild.createServerReference(deleteId);

          action(. id);
        }
      )
    };

  module Registers = {
    [@platform native]
    ServerReference.register(createId, createRouteHandler);

    [@platform native]
    ServerReference.register(editId, editRouteHandler);

    [@platform native]
    ServerReference.register(deleteId, deleteRouteHandler);
  };
};

module Samples = {
  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let simpleResponse = () => {
      Lwt.return(
        (`String("Hello from server with simple response action")),
      );
    };
  */
  // It's going to be on top to this that we are going to generate the codes bellow
  let simpleResponseId = "id/samples/simpleResponse";

  [@platform native]
  let simpleResponseHandler = () => {
    Lwt.return(`String("Hello from server with simple response action"));
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let simpleResponseRouteHandler = _args =>
    simpleResponseHandler() |> Lwt.map(response => React.Json(response));

  let simpleResponse =
    switch%platform () {
    | Server => failwith("We don't support Server Functions on server ")
    | Client => (
        _ => {
          let action =
            ReactServerDOMEsbuild.createServerReference(simpleResponseId);
          action(.);
        }
      )
    };
};
