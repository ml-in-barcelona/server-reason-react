module Notes = {
  [@platform native]
  let createNoteResponse = note => {
    Note.(
      `Assoc([
        ("id", `Int(note.id)),
        ("title", `String(note.title)),
        ("content", `String(note.content)),
        ("updated_at", `Float(note.updated_at)),
      ])
    );
  };

  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let createHandler = (~title, ~content) => {
      let note = DB.addNote(~title, ~content);
      let%lwt response =
        switch%lwt (note) {
        | Ok(note) => Lwt.return(createNoteResponse(note))
        | Error(e) => failwith(e)
        };
      Lwt.return(response);
    };
   */
  // It's going to be on top to this that we are going to generate the codes bellow
  let createId = "id/notes/create";

  [@platform native]
  let createHandler = (~title, ~content) => {
    let note = DB.addNote(~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(note)
      | Error(e) => failwith(e)
      };
    Lwt.return(response);
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let createRouteHandler = args => {
    // Parse the body to get the args
    let (title, content) =
      switch (args) {
      | [title, content] => (
          // It would be handle by a title_of_json/content_of_json in the future provided by the end-user and the ppx
          title |> Yojson.Basic.Util.to_string,
          content |> Yojson.Basic.Util.to_string,
        )
      | _ =>
        failwith(
          Printf.sprintf(
            "Invalid arguments %s",
            args
            |> List.map(Yojson.Basic.Util.to_string)
            |> String.concat(","),
          ),
        )
      };

    let encodeResponse = response =>
      React.Json(createNoteResponse(response));

    createHandler(~title, ~content) |> Lwt.map(encodeResponse);
  };

  // This is the action generated to be used under the hood for the server and client
  // Melange don't display the comment after compilation
  // This is a little hack while we don't have the ppx to generate the comment
  switch%platform () {
  | Server => ()
  | Client => [%mel.raw
     {|
    // extract-server-function id/notes/create create Notes
    ''
    |}
    ]
  };
  let create =
    switch%platform () {
    | Server => {
        Runtime.id: createId,
        call: ((. ~title, ~content) => createHandler(~title, ~content)),
      }
    | Client => {
        Runtime.id: createId,
        call: (
          (. ~title, ~content) => {
            let action =
              ReactServerDOMEsbuild.createServerReference(createId);
            action(. title, content);
          }
        ),
      }
    };

  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let editHandler = (~id, ~title, ~content) => {
      let note = DB.editNote(~id, ~title, ~content);
      let%lwt response =
        switch%lwt (note) {
        | Ok(note) => Lwt.return(createNoteResponse(note))
        | Error(e) => failwith(e)
        };
      Lwt.return(response);
    };
  */
  // It's going to be on top to this that we are going to generate the codes bellow
  let editId = "id/notes/edit";

  [@platform native]
  let editHandler = (~id, ~title, ~content) => {
    let note = DB.editNote(~id, ~title, ~content);
    let%lwt response =
      switch%lwt (note) {
      | Ok(note) => Lwt.return(note)
      | Error(e) => failwith(e)
      };

    Lwt.return(response);
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let editRouteHandler = args => {
    // Parse the body to get the args
    // This will be generated by some ppx
    let (id, title, content) =
      switch (args) {
      | [id, title, content] => (
          // It would be handle by a id_of_json/title_of_json/content_of_json in the future provided by the end-user and the ppx
          id |> Yojson.Basic.Util.to_int,
          title |> Yojson.Basic.Util.to_string,
          content |> Yojson.Basic.Util.to_string,
        )
      | _ =>
        failwith(
          Printf.sprintf(
            "Invalid arguments %s",
            args
            |> List.map(Yojson.Basic.Util.to_string)
            |> String.concat(","),
          ),
        )
      };

    let encodeResponse = response =>
      React.Json(createNoteResponse(response));

    editHandler(. ~id, ~title, ~content) |> Lwt.map(encodeResponse);
  };

  // This is the action generated to be used under the hood for the server and client
  // Melange don't display the comment after compilation
  // This is a little hack while we don't have the ppx to generate the comment
  switch%platform () {
  | Server => ()
  | Client => [%mel.raw
     {|
    // extract-server-function id/notes/edit edit Notes
    ''
    |}
    ]
  };
  let edit =
    switch%platform () {
    | Server => {
        Runtime.id: editId,
        call: (
          (. ~id, ~title, ~content) => editHandler(. ~id, ~title, ~content)
        ),
      }
    | Client => {
        Runtime.id: editId,
        call: (
          (. ~id, ~title, ~content) => {
            let action = ReactServerDOMEsbuild.createServerReference(editId);
            action(. id, title, content);
          }
        ),
      }
    };

  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let deleteHandler = (~id) => {
      let _ = DB.deleteNote(id);
      let response = `String("Note deleted");
      Lwt.return(response);
    };
  */
  // It's going to be on top to this that we are going to generate the codes bellow
  let deleteId = "id/notes/delete";

  [@platform native]
  let deleteHandler = (~id) => {
    let _ = DB.deleteNote(id);
    Lwt.return("Note deleted");
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let deleteRouteHandler = args => {
    // Parse the body to get the args
    // This will be generated by some ppx
    let id =
      // It would be handle by a id_of_json in the future provided by the end-user and the ppx
      switch (args) {
      | [id] => id |> Yojson.Basic.Util.to_int
      | _ =>
        failwith(
          Printf.sprintf(
            "Invalid arguments %s",
            args
            |> List.map(Yojson.Basic.Util.to_string)
            |> String.concat(","),
          ),
        )
      };

    let encodeResponse = response => React.Json(`String(response));

    deleteHandler(~id) |> Lwt.map(encodeResponse);
  };

  // This is the action generated to be used under the hood for the server and client
  // Melange don't display the comment after compilation
  // This is a little hack while we don't have the ppx to generate the comment
  switch%platform () {
  | Server => ()
  | Client => [%mel.raw
     {|
    // extract-server-function id/notes/delete $$delete Notes
    ''
    |}
    ]
  };
  let delete =
    switch%platform () {
    | Server => {
        Runtime.id: deleteId,
        call: ((. ~id) => deleteHandler(~id)),
      }
    | Client => {
        Runtime.id: deleteId,
        call: (
          (. ~id) => {
            let action =
              ReactServerDOMEsbuild.createServerReference(deleteId);

            action(. id);
          }
        ),
      }
    };

  module Registers = {
    [@platform native]
    ServerReference.registerBodyFunction(createId, createRouteHandler);

    [@platform native]
    ServerReference.registerBodyFunction(editId, editRouteHandler);

    [@platform native]
    ServerReference.registerBodyFunction(deleteId, deleteRouteHandler);
  };
};

module Samples = {
  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let simpleResponse = () => {
      Lwt.return(
        (`String("Hello from server with simple response action")),
      );
    };
  */
  // It's going to be on top to this that we are going to generate the codes bellow
  let simpleResponseId = "id/samples/simpleResponse";

  [@platform native]
  let simpleResponseHandler =
    (. ~name, ~age) => {
      Lwt.return(
        Printf.sprintf("Hello %s, you are %d years old", name, age),
      );
    };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let simpleResponseRouteHandler = args => {
    let (name, age) =
      switch (args) {
      | [name, age] => (
          name |> Yojson.Basic.Util.to_string,
          age |> Yojson.Basic.Util.to_int,
        )
      | _ => failwith("Invalid arguments")
      };

    let encodeResponse = response => React.Json(`String(response));
    simpleResponseHandler(~name, ~age) |> Lwt.map(encodeResponse);
  };

  // This is the action generated to be used under the hood for the server and client
  // Melange don't display the comment after compilation
  // This is a little hack while we don't have the ppx to generate the comment
  switch%platform () {
  | Server => ()
  | Client =>
    // Comment to esbuild create the manifest
    [%mel.raw
     {|
    // extract-server-function id/samples/simpleResponse simpleResponse Samples
    ''
    |}
    ]
  };
  let simpleResponse =
    switch%platform () {
    | Server => {
        Runtime.id: simpleResponseId,
        call: ((. ~name, ~age) => simpleResponseHandler(. ~name, ~age)),
      }
    | Client => {
        Runtime.id: simpleResponseId,
        call: (
          (. ~name, ~age) => {
            let action =
              ReactServerDOMEsbuild.createServerReference(simpleResponseId);

            action(. ~name, ~age);
          }
        ),
      }
    };

  // Lets say this is the server action declared by the end-user
  /**
    [@react.server.action]
    let simpleResponse = () => {
      Lwt.return(
        (`String("Hello from server with simple response action")),
      );
    };
  */
  // It's going to be on top to this that we are going to generate the codes bellow
  let errorId = "id/samples/error";

  [@platform native]
  let errorHandler = () => {
    // Uncomment to see that it also works with Lwt.fail
    // Lwt.fail(failwith("Error from server"));
    Lwt.fail(
      failwith("Error from server"),
    );
  };

  // This is the router  handler that will handle parsing the args and calling the handler the user declared
  // This code will be generated by the ppx automatically
  [@platform native]
  let errorRouteHandler = _args =>
    try%lwt(errorHandler() |> Lwt.map(response => response)) {
    | exn => Lwt.fail(exn)
    };

  // This is the action generated to be used under the hood for the server and client
  // Melange don't display the comment after compilation
  // This is a little hack while we don't have the ppx to generate the comment
  switch%platform () {
  | Server => ()
  | Client =>
    // Comment to esbuild create the manifest
    [%mel.raw
     {|
    // extract-server-function id/samples/simpleResponse simpleResponse Samples
    ''
    |}
    ]
  };
  let error =
    switch%platform () {
    | Server => {
        Runtime.id: errorId,
        call: _ => errorHandler(),
      }
    | Client => {
        Runtime.id: errorId,
        call: _ => {
          let action = ReactServerDOMEsbuild.createServerReference(errorId);
          action(.);
        },
      }
    };

  let formDataId = "id/samples/formData";

  [@platform native]
  let formDataRouteHandler = formData => {
    let (name, lastName, age) =
      switch (
        formData->FormData.get("name"),
        formData->FormData.get("lastName"),
        formData->FormData.get("age"),
      ) {
      | (`String(name), `String(lastName), `String(age)) => (
          name,
          lastName,
          age,
        )
      | exception _ => failwith("Invalid formData.")
      };

    let response =
      Printf.sprintf("Form data received: %s, %s, %s", name, lastName, age);

    Lwt.return(React.Json(`String(response)));
  };

  let formData =
    switch%platform () {
    | Server => {
        Runtime.id: formDataId,
        call: ((. formData: FormData.t) => formDataRouteHandler(formData)),
      }
    | Client => {
        Runtime.id: formDataId,
        call: (
          (. formData: Js.FormData.t) => {
            let action =
              ReactServerDOMEsbuild.createServerReference(formDataId);
            action(. formData);
          }
        ),
      }
    };

  module Registers = {
    [@platform native]
    ServerReference.registerBodyFunction(
      simpleResponseId,
      simpleResponseRouteHandler,
    );

    [@platform native]
    ServerReference.registerBodyFunction(errorId, errorRouteHandler);

    [@platform native]
    ServerReference.registerFormFunction(formDataId, formDataRouteHandler);
  };
};
