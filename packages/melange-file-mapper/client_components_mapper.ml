module List = ListLabels
open Sexplib

exception Invalid_sexp of string

let invalid_sexp str = raise (Invalid_sexp str)

let raise_decoding_error_atom_found atom =
  invalid_sexp (Printf.sprintf "Expect a list, got an atom %s" (Sexp.to_string_hum atom))

let raise_decoding_error_list_found list =
  invalid_sexp (Printf.sprintf "Expect a list of (atom and list), got a list %s" (Sexp.to_string_hum list))

let decode (sexp : Sexp.t) : (string * string) list =
  match sexp with
  | Sexp.List l ->
      List.map l ~f:(fun sexp ->
          match (sexp : Sexp.t) with
          (* FIXME: We are assume that the path is only one atom, when in reality we know that it might be a list of paths or cjs/es6 list. Depends on https://github.com/davesnx/dune/pull/1 *)
          | List [ Sexp.Atom name; Sexp.List [ Sexp.Atom path ] ] -> (name, path)
          | List _ -> raise_decoding_error_list_found sexp
          | Atom _ -> raise_decoding_error_atom_found sexp)
  | Atom _ -> raise_decoding_error_atom_found sexp

let write_file (path : string) (content : string) : unit =
  Out_channel.with_open_text path (fun oc ->
      Out_channel.output_string oc content;
      Out_channel.close oc)

let render_manifest ~path (manifest : (string * string) list) =
  let register_client_components =
    List.map manifest ~f:(fun (original_path, compiled_js_path) ->
        let _module_name =
          original_path |> Filename.basename (* Gets "xxx.re" from the full path *)
          |> Filename.remove_extension (* Removes ".re" extension *)
        in
        Printf.sprintf
          "window.__client_manifest_map[\"%s\"] = React.lazy(() => import(\"./%s\").then(module => {\n\
          \  return { default: module.make_client }\n\
           }))"
          original_path compiled_js_path)
  in
  let content =
    Printf.sprintf
      {|// Generated by client_components_mapper
const React = require("react");
window.__client_manifest_map = window.__client_manifest_map || {};
%s|}
      (String.concat "\n" register_client_components)
  in
  write_file path content

let () =
  let argv = Array.to_list Sys.argv in
  let first_arg = List.nth_opt argv 1 in
  let path = Option.value ~default:"./bootstrap.js" first_arg in
  let sexp =
    Sexp.of_string
      "((demo/universal/native/lib/Counter.re (app/demo/universal/js/Counter.js))\n\
       (demo/universal/native/lib/Note_editor.re (app/demo/universal/js/Note_editor.js))\n\
       (demo/universal/native/lib/Debug_props.re (app/demo/universal/js/Debug_props.js))\n\
       )"
  in
  match decode sexp with
  | manifest -> render_manifest ~path manifest
  | exception Invalid_sexp message ->
      Printf.printf "Invalid sexp: %s. Generated an empty bootstrap.js file" message;
      render_manifest ~path []
  | exception exn ->
      Printf.printf "Unexpected error: %s. Generated an empty bootstrap.js file" (Printexc.to_string exn);
      render_manifest ~path []
