module List = ListLabels

let read_file path = try Some (In_channel.with_open_bin path In_channel.input_all) with _ -> None

type manifest_item = { original_path : string; compiled_js_path : string; module_name : string option }
type manifest = manifest_item list

(* // extract-client input.re Prop_with_many_annotation *)
let parse_line line =
  try
    Scanf.sscanf line "// extract-client %s %s" (fun filename module_name ->
        Ok (filename, if module_name = "" then None else Some module_name))
  with End_of_file | Scanf.Scan_failure _ -> Error "Invalid extract command format"

let parse_manifest_data ~path content : manifest_item list =
  String.split_on_char '\n' content
  |> List.filter_map ~f:(fun line ->
         match parse_line (String.trim line) with
         | Ok (original_path, module_name) -> Some { compiled_js_path = path; original_path; module_name }
         | Error _ -> None)

let render_manifest (manifest : manifest) =
  let register_client_components =
    List.map manifest ~f:(fun { original_path; compiled_js_path; module_name } ->
        (* let _module_name =
          original_path |> Filename.basename (* Gets "xxx.re" from the full path *)
          |> Filename.remove_extension (* Removes ".re" extension *)
        in *)
        let export =
          match module_name with
          | Some name ->
              ignore @@ failwith @@ Printf.sprintf "module name is '%s'" name;
              Printf.sprintf "%s.make_client" name
          | None -> "make_client"
        in
        Printf.sprintf
          "window.__client_manifest_map[\"%s\"] = React.lazy(() => import(\"%s\").then(module => {\n\
          \  return { default: module.%s }\n\
           }))"
          original_path compiled_js_path export)
  in
  Printf.sprintf
    {|// Generated by client_components_mapper
const React = require("react");
window.__client_manifest_map = window.__client_manifest_map || {};
%s|}
    (String.concat "\n" register_client_components)

let is_js_file path =
  let ext = Filename.extension path in
  ext = ".js" || ext = ".bs.js"

(* TODO: refactor path to be a Filepath *)
let capture_all_client_component_files_in_target path =
  let rec traverse_fs path =
    try
      match Sys.is_directory path with
      | true ->
          (* Handle directory *)
          let contents = Sys.readdir path in
          Array.fold_left
            (fun acc entry ->
              let full_path = Filename.concat path entry in
              match acc with
              | Ok files -> (
                  match traverse_fs full_path with Ok new_files -> Ok (files @ new_files) | Error err -> Error err)
              | Error err -> Error err)
            (Ok []) contents
      | false ->
          (* Handle file *)
          if is_js_file path then
            match read_file path with
            | Some content -> Ok (parse_manifest_data ~path content)
            | None -> Error (Printf.sprintf "Failed to read file: %s" path)
          else Ok []
    with
    | Sys_error msg -> Error (Printf.sprintf "System error: %s" msg)
    | Unix.Unix_error (err, _, _) -> Error (Printf.sprintf "Unix error: %s" (Unix.error_message err))
    | e -> Error (Printf.sprintf "Unexpected error: %s" (Printexc.to_string e))
  in
  traverse_fs path

open Cmdliner

(* Command-line arguments *)
let melange_target =
  let doc = "Path to the melange target directory (melange.emit (target xxx))" in
  Arg.(required & pos 0 (some string) None & info [] ~docv:"MELANGE_TARGET" ~doc)

let extract_components target =
  let current_dir = Sys.getcwd () in
  let melange_target = Filename.concat current_dir target in
  match capture_all_client_component_files_in_target melange_target with
  | Ok manifest ->
      print_endline (render_manifest manifest);
      Ok ()
  | Error msg ->
      prerr_endline msg;
      Error (`Msg msg)

let extract_cmd =
  let doc = "Extract all client components from a Melange target folder" in
  let sdocs = Manpage.s_common_options in
  let info = Cmd.info "extract-client-components" ~version:"1.0.0" ~doc ~sdocs in
  let term = Term.(term_result (const extract_components $ melange_target)) in
  Cmd.v info term

let () = exit (Cmd.eval extract_cmd)
